---
title: 摘樱桃
difficulty: Hard
date: 2024-05-06 05:12:58
url: https://leetcode.cn/problems/cherry-pickup
tags:
    - DP
---
# 741. 摘樱桃

## 描述

给你一个 `n x n` 的网格 `grid` ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：

- `0` 表示这个格子是空的，所以你可以穿过它。
- `1` 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
- `-1` 表示这个格子里有荆棘，挡着你的路。

请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：

- 从位置 `(0, 0)` 出发，最后到达 `(n - 1, n - 1)` ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 `0` 或者 `1` 的格子）；
- 当到达 `(n - 1, n - 1)` 后，你要继续走，直到返回到 `(0, 0) `，只能向上或向左走，并且只能穿越有效的格子；
- 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 `0` ）；
- 如果在 `(0, 0)` 和 `(n - 1, n - 1)` 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

## 样例
### 示例 1
<img alt="" src="https://assets.leetcode.com/uploads/2020/12/14/grid.jpg" />

```
输入：grid = [[0,1,-1],[1,0,-1],[1,1,1]]
输出：5
解释：玩家从 (0, 0) 出发：向下、向下、向右、向右移动至 (2, 2) 。
在这一次行程中捡到 4 个樱桃，矩阵变成 [[0,1,-1],[0,0,-1],[0,0,0]] 。
然后，玩家向左、向上、向上、向左返回起点，再捡到 1 个樱桃。
总共捡到 5 个樱桃，这是最大可能值。
```

### 示例 2

```
输入：grid = [[1,1,-1],[1,-1,1],[-1,1,1]]
输出：0
```

## 限制

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 50`
- `grid[i][j]` 为 `-1`、`0` 或 `1`
- `grid[0][0] != -1`
- `grid[n - 1][n - 1] != -1`


## 思考
没思路，只能想到暴力。

## [题解](solution.cpp)
DP。

重点在于将 一来一回 等价于 俩人从起点同时出发。

可设两人速度相同，则可以用`(步数k, 甲的横坐标x1, 乙的横坐标x2)`表示状态，此时两人的位置分别为`(x1, k - x1)`与`(x2, k - x2)`。

转移方程比较简单，注意可以循环使用数组节省一维空间。
另外，可以限定`x1 <= x2`，即设定甲始终走在乙的上方，减小常数。
